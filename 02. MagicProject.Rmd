---
title: "Sorting Magic: The Gathering Cards by Color"
author: "Ted Tinker and Lilian Lu"
date: "December 2017"
output: pdf_document
---

\section{Abstract}

Magic: The Gathering (MTG) is a collectible-card-game set in a fantasy multiverse. Since its introduction in 1993 more than 17,000 MTG cards have been designed and published in more than seventy sets. The cards vary in type and complexity, but all them have one of thirty-two Color Identities: either Colorless (C) or any combination of White (W) Blue (U) Black (B) Red (R) and Green (G). These colors relate to game-world idealogies, so the Color Identity of a card usually reflects what it might be able to do when played. A complete set of MTG card-data is available in a JSON file from mtgjson.com, but the JSON format is inconvenient in RStudio. In this project we parce the JSON file into a dataframe so we may use Rstudio to answer the following questions:

How does a card's Color Identity influence the rest of its statistics? Based on that, can a card's statistics be used to algorithmically predict its Color Identity? And, how do these questions relate to the design philosophy of Magic's creators? We elected to generate supervised classification models based on random forests and logistic regressions. Once we select the better model, we'll examine its predictions to explain elements of Magic's design. 

Our model consisting of six random forests (one to predict the presence of each of the five colors in a card's Color Identity, and a sixth to synthesize their outputs into a final guess) is quite proficient. On average its guess is only wrong by one color out of five. 

Our model consisting of six linear regressions has a slightly lower test error, but tends to guess single colors and therefore is not very accurate when applied to multicolored cards. Still, its predictions differ from test Color Identities by less than one color out of five. 

Overall both models are surprisingly proficient, though the random forest model's predictions are difficult to justify while the regressions tend to fail on multicolored cards (which make up a fair portion of the data). 

\section{Introduction}

Our primary goal is to consistently algorithmically sort Magic: The Gathering cards by Color Identity based on the rest of their statistics (excluding statistics which make the problem nearly trivial). This is difficult because Magic: The Gathering cards come in a variety of types and levels of complexity, and Color Identity is the product of subjective game-design considerations by the designers. Expert humans are able to assign Color Identities to cards with ease; Mark Rosewater, Magic: The Gathering's head designer, arbitrates the color-philosophies with intricate precision. In "Mechanical Color Pie 2017" he associates every keyword in the game's standard lexicon with each color at one of four levels: primary, secondary, tertiary, or none of the above. Given the detailed knowledge required to accurately enforce the color-philosophies, an algorithm for assigning Color Identity based on card-data may be useful for designing the game or understanding the game's design.

This project is inspired by the RoboRosewater twitter account. This twitter account posts the output of a neural network trained on Magic: The Gathering cards. Some of RoboRosewater's cards are humorously unreadable; others are syntactically correct and theoretically playable. However, even RoboRosewater's best cards have mismatched Color Identities because the program cannot grasp the subtle intricacies of "flavor," or relation to in-game lore and philosophies. This project endeavors to improve automatic Color Identity identification.

The dataset of all Magic: The Gathering cards was downloaded from mtgjson.com in the form of a JSON file. JSON is a natural choice for Magic: The Gathering cards because the cards have inconsistant variables based on their card-type. Some variables have high consistency (for example, each card has a name), but some variables may not be present on all card types (for example, only creature cards have power and toughness), and some variables are lists whose lengths vary from card to card (for example, the list of all sets in which the card was printed). The data was most likely scraped from Gatherer, Magic's official online card index. Therefore the data is accurate and complete, but in a format which Rstudio cannot easily handle. 

The Color Identity of a card is often reflected by its mana cost, the price a player must pay to put the card from their hand onto the table, so the mana cost should be ignored in our models as it mostly trivializes the problem. For the same reason we will not search each card's text-box for color-symbols. 

Because each of five colors can be either present or absent in a card's Color Identity, there are $2^5 = 32$ possible Color Identities ranging from Colorless (C) to five-colored (WUBRG). It might be troublesome to make a model which selects the correct factor out of thirty-two because of the overlaps in color-philosophies and behavior of multicolored cards, so we resolved to make quintets of models which predict the probability that each of the five colors is present in a card's Color Identity, and then compile the results of these quintets to produce our final guesses. Our error function will therefore use Hamming Distance to compare our predicted Color Identity to the True Color Identity. 

Both of our models (based on random forests are logistic regressions) are surprisingly adept at assigning cards Color Identities; both have an average error of less than one color per guess. However, the logistic regression model tends to guess single-color identities far more often than it should, making it quite accurate on cards with at most one color in their Color Identity and mostly inaccurate on multicolored cards. Therefore the random forest model may be more useful. 

\section{Data and Methods}

```{r setup,results="hide"}
# install.packages("tidyverse")       # Installation only necessary on the first run
# install.packages("rjson")
# install.packages("gtools")
# install.packages("stringr")
# install.packages("ggplot2")
# install.packages("stringi")
# install.packages("tree")
# install.packages("maptree")
# install.packages("randomForest")
# install.packages("stringdist")
# install.packages("plyr")
# install.packages("ROCR")

library(tidyverse)
library(rjson)      # To read JSON
library(gtools)   
library(stringr)    # To interact with strings
library(ggplot2)    # Nice plots
library(stringi)    # Regex parsing
library(tree)
library(maptree)
library(randomForest)
library(stringdist) # Hamming Distance
library(plyr)       # mapvalues()
library(ROCR)
#setwd('~/Downloads')
setwd("/Users/Theodore/Desktop/R_Studio_Stuff/data")  # Change this to your own directory
MTG.json <- fromJSON(file="AllCards.json",method='C') 
    # JSON file from https://mtgjson.com (not great for R)

rows=17761    # When testing, decrease this so you don't use the whole data-set every time

MTG.df <- data.frame(matrix(ncol=15,nrow=rows))   # Start with 15 variables; generate more
```
Here is an example of a typical card in JSON format:
```{r jsonExample}
MTG.json[["Serra Angel"]]
```
Clearly this must be parsed to yield useful information in RStudio. Notice how the mana cost of the card reveals its Color Identity, which is why we should ignore mana cost in our models to avoid trivializing the problem. The following chunk should probably be run in a separate script for stability reasons.
```{r parse, cache=TRUE,results="hide"}
     # The function "isItThere" is vital to parsing JSON. 
     # Nested lists and inconsistant variable types require it 
     # for producing consistant dataframe row-lengths.
     # The argument "json" is a JSON object.
     # "x" is the position in the JSON list to open; 
     # each will be a Magic: The Gathering card.
     # "string" is the name of the variable to check for in the JSON element x.
     # "otherwise" is what the program should return 
     # if the variable doesn't exist; sometimes "", sometimes NA.
     # "after" is the nested list index in case we need to check 
     # elements of a nested list which may not exist.
isItThere <- function(json,x,string,otherwise,after="") {
  if(after!="") {if(is.null(json[[x]][[string]][after])) {return(otherwise)} else
  {return(json[[x]][[string]][after])}} else
    if(is.null(json[[x]][[string]])) {return(otherwise)} else {return(json[[x]][[string]])}}

     # Color-identity is expressed as up to five of the characters WUBR and G. 
sapply(1:rows, function(x) {colorIdentity <- c(isItThere(MTG.json,x,"colorIdentity",NA,1),
                                               isItThere(MTG.json,x,"colorIdentity",NA,2),
                                               isItThere(MTG.json,x,"colorIdentity",NA,3),
                                               isItThere(MTG.json,x,"colorIdentity",NA,4),
                                               isItThere(MTG.json,x,"colorIdentity",NA,5))
colorIdentity <- colorIdentity[!is.na(colorIdentity)]

     # Supertype, Type, and Subtype are collections of zero to three character strings        
supertype <- c(isItThere(MTG.json,x,"supertypes",NA,1),
               isItThere(MTG.json,x,"supertypes",NA,2),
               isItThere(MTG.json,x,"supertypes",NA,3))
supertype <-supertype[!is.na(supertype)]
                            
type <- c(isItThere(MTG.json,x,"types",NA,1),
          isItThere(MTG.json,x,"types",NA,2),
          isItThere(MTG.json,x,"types",NA,3))
type <-type[!is.na(type)]
                            
subtype <- c(isItThere(MTG.json,x,"subtypes",NA,1),
             isItThere(MTG.json,x,"subtypes",NA,2),
             isItThere(MTG.json,x,"subtypes",NA,3))
subtype <-subtype[!is.na(subtype)]
     # Once these character variables are set, we will decompose them into factors

     # The list of printings is a collection of character-string abbreviations of set-names.  
     # We will decompose it into printing dates later.
printList <- c(unlist(lapply(1:length(MTG.json[[x]][["printings"]]),function (y)
                            {MTG.json[[x]][["printings"]][[y]]})))
  
MTG.df[x,] <<- c(MTG.json[[x]][["name"]],     # We describe all variables as we name them below
                 paste(colorIdentity,collapse=""),
                 MTG.json[[x]][["cmc"]],
                 paste(supertype,collapse=" "),
                 paste(type,collapse=" "),
                 paste(subtype,collapse=" "),
                 isItThere(MTG.json,x,"text",NA),
                 nchar(isItThere(MTG.json,x,"text","")),
                 isItThere(MTG.json,x,"power",NA),
                 isItThere(MTG.json,x,"toughness",NA),
                 isItThere(MTG.json,x,"loyalty",NA),
                 length(MTG.json[[x]][["rulings"]]),
                 length(MTG.json[[x]][["legalities"]]),
                 length(MTG.json[[x]][["printings"]]),
                 paste(printList, collapse=" "))})
```
Now we add column names and types:
```{r columnNames,cache=TRUE,results="hide"}
MTG.df <- setNames(MTG.df,c("Name",                 # Character; MTG card name
                            "ColorIdentity",        # Factor; Color Identity
                            "ConvertedManaCost",    # Integer; number of mana required to cast
                            "Supertype",            # Character; broad categories
                            "Type",                 # Character; main card types
                            "Subtype",              # Character; supplimentary types
                            "Text",                 # Character; Rules text, not flavor text
                            "TextLength",           # Integer; number of characters in Text
                            "Power",                # Often an integer, sometimes a character
                            "Toughness",            # Often an integer, sometimes a character
                            "Loyalty",              # Integer; for Planeswalkers
                            "Rulings",              # Number of rulings
                            "Legalities",           # Number of legalities
                            "Printings",            # Number of printings
                            "PrintingsList"))       # Character; all set abbrvs

MTG.df <- transmute(MTG.df, Name=as.character(Name),
                    ColorIdentity=factor(ColorIdentity),
                    ConvertedManaCost=as.integer(ConvertedManaCost),
                    Supertype=as.character(Supertype),
                    Type=as.character(Type),
                    Subtype=as.character(Subtype),
                    Text=as.character(Text),
                    TextLength=as.integer(TextLength),
                    Power=as.character(Power),         # Mostly integers, some odd characters
                    Toughness=as.character(Toughness), # Mostly integers, some odd characters
                    Loyalty=as.integer(Loyalty),
                    Rulings=as.integer(Rulings),
                    Legalities=as.integer(Legalities),
                    Printings=as.integer(Printings),
                    PrintingsList=as.character(PrintingsList))

     # The color identities should be in this order
MTG.df <- mutate(MTG.df,ColorIdentity=factor(ColorIdentity,levels=c("C","W","U","B","R","G",
                 "WU","WB","WR","WG","UB","UR","UG","BR","BG","RG","WUB","WUR","WUG","WBR",
                 "WBG","WRG","UBR","UBG", "URG","BRG","WUBR", "WUBG","WURG","WBRG",
                 "UBRG","WUBRG"))) 
MTG.df$ColorIdentity[is.na(MTG.df$ColorIdentity)] <- "C" 

     # Power and Toughness have some irregularities which should be sorted
MTG.df <- mutate(MTG.df,Power=factor(Power,levels=c("", "*","-1",".5","0","1","1.5","1+*","2",
          "2.5","2+*","3","3.5","4","5","6","7","8","9","10","11","12","13","15","99")))
MTG.df$Power[is.na(MTG.df$Power)] <- ""

MTG.df <- mutate(MTG.df,Toughness=factor(Toughness,levels=c("", "*","-1",".5","0","1","1.5",
          "1+*","2","2.5","2+*","3","3.5","4","5","6","7","7-*","8","9","10","11","12","13",
          "14","15","99")))
MTG.df$Toughness[is.na(MTG.df$Toughness)] <- ""
```
The supertypes, types, and subtypes of a card may be decomposed into some explanatory factors:
```{r types}
MTG.df <- mutate(MTG.df, Legend = str_count(MTG.df$Supertype,"Legendary"),
                 Basic = str_count(MTG.df$Supertype,"Basic"),
                 
                 Artifact = str_count(MTG.df$Type,"Artifact"),
                 Creature =str_count(MTG.df$Type,"Creature")+ 
                   str_count(MTG.df$Type,"EastureCray"), # A card in a joke set is in pig-latin
                 Enchantment = str_count(MTG.df$Type,"Enchantment"),
                 Land = str_count(MTG.df$Type,"Land"),
                 Instant = str_count(MTG.df$Type,"Instant"),
                 Sorcery = str_count(MTG.df$Type,"Sorcery"),
                 Tribal = str_count(MTG.df$Type,"Tribal"),
                 Planeswalker = str_count(MTG.df$Type,"Planeswalker"))
     # We performed a similar mutation on the subtypes, but it's too lengthy to include.
```

```{r subtypes,include=FALSE}
     # Subtypes were included only if about 100 examples were available
MTG.df <- mutate(MTG.df,
                 Artificer  = str_count(MTG.df$Subtype,"Artificer"),
                 Angel = str_count(MTG.df$Subtype,"Angel"),
                 Aura = str_count(MTG.df$Subtype,"Aura"),
                 Beast = str_count(MTG.df$Subtype,"Beast"),
                 Bird  = str_count(MTG.df$Subtype,"Bird"),
                 Cat = str_count(MTG.df$Subtype,"Cat"),
                 Cleric = str_count(MTG.df$Subtype,"Cleric"),
                 Construct = str_count(MTG.df$Subtype,"Construct"),
                 Demon = str_count(MTG.df$Subtype,"Demon"),
                 Dragon = str_count(MTG.df$Subtype,"Dragon"),
                 Giant = str_count(MTG.df$Subtype,"Giant"),
                 Knight = str_count(MTG.df$Subtype,"Knight"),
                 Shaman = str_count(MTG.df$Subtype,"Shaman"),
                 Druid = str_count(MTG.df$Subtype,"Druid"),
                 Eldrazi = str_count(MTG.df$Subtype,"Eldrazi"),
                 Elemental = str_count(MTG.df$Subtype,"Elemental"),
                 Elf = str_count(MTG.df$Subtype,"Elf"),
                 Equipment = str_count(MTG.df$Subtype,"Equipment"),
                 Golem = str_count(MTG.df$Subtype,"Golem"),
                 Human = str_count(MTG.df$Subtype,"Human"),
                 Horror = str_count(MTG.df$Subtype,"Horror"),
                 Illusion = str_count(MTG.df$Subtype,"Illusion"),
                 Insect = str_count(MTG.df$Subtype,"Insect"),
                 Merfolk = str_count(MTG.df$Subtype,"Merfolk"),
                 Monk = str_count(MTG.df$Subtype,"Monk"),
                 Rogue = str_count(MTG.df$Subtype,"Rogue"),
                 Scout  = str_count(MTG.df$Subtype,"Scout"),
                 Soldier = str_count(MTG.df$Subtype,"Soldier"),
                 Shapeshifter = str_count(MTG.df$Subtype,"Shapeshifter"),
                 Spirit = str_count(MTG.df$Subtype,"Spirit"),
                 Sliver = str_count(MTG.df$Subtype,"Sliver"),
                 Snake = str_count(MTG.df$Subtype,"Snake"),
                 Vampire = str_count(MTG.df$Subtype,"Vampire"),
                 Warrior = str_count(MTG.df$Subtype,"Warrior"),
                 Wall = str_count(MTG.df$Subtype,"Wall"),
                 Werewolf = str_count(MTG.df$Subtype,"Werewolf"),
                 Wizard = str_count(MTG.df$Subtype,"Wizard"),
                 Wurm = str_count(MTG.df$Subtype,"Wurm"),
                 Zombie = str_count(MTG.df$Subtype,"Zombie"))
```
PrintingsList is not a convenient way to check when cards were published. The following mutation is an example of a series of mutations we applied to the data to turn card-set abbreviations into printing years:
```{r yearsExample}
MTG.df <- mutate(MTG.df, y1993 = as.numeric(str_count(MTG.df$PrintingsList,"LEA") >= 1|
                                           str_count(MTG.df$PrintingsList,"LEB") >= 1|
                                           str_count(MTG.df$PrintingsList,"2ED") >= 1|
                                           str_count(MTG.df$PrintingsList,"ARN") >= 1))
     # The sets Alpha, Beta, Second Edition, and Arabian Nights were printed in 1993.
     # We performed a similar mutation for every year up to 2018.
```

```{r years, include=FALSE}
MTG.df <- mutate(MTG.df, y1994 = as.numeric(str_count(MTG.df$PrintingsList,"ATQ") >= 1|
                                   str_count(MTG.df$PrintingsList,"3ED") >= 1|
                                   str_count(MTG.df$PrintingsList,"LEG") >= 1|
                                   str_count(MTG.df$PrintingsList,"DRK") >= 1|
                                   str_count(MTG.df$PrintingsList,"FEM") >= 1),
                 y1995 = as.numeric(str_count(MTG.df$PrintingsList,"4ED") >= 1|
                                   str_count(MTG.df$PrintingsList,"ICE") >= 1|
                                   str_count(MTG.df$PrintingsList,"CHR") >= 1|
                                   str_count(MTG.df$PrintingsList,"HML") >= 1),
                 y1996 = as.numeric(str_count(MTG.df$PrintingsList,"ALL") >= 1|
                                   str_count(MTG.df$PrintingsList,"MIR") >= 1),
                 y1997 = as.numeric(str_count(MTG.df$PrintingsList,"5ED") >= 1|
                                   str_count(MTG.df$PrintingsList,"POR") >= 1|
                                   str_count(MTG.df$PrintingsList,"WTH") >= 1|
                                   str_count(MTG.df$PrintingsList,"TMP") >= 1),
                 y1998 = as.numeric(str_count(MTG.df$PrintingsList,"STH") >= 1|
                                   str_count(MTG.df$PrintingsList,"EXO") >= 1|
                                   str_count(MTG.df$PrintingsList,"PO2") >= 1|
                                   str_count(MTG.df$PrintingsList,"UGL") >= 1|
                                   str_count(MTG.df$PrintingsList,"USG") >= 1|
                                   str_count(MTG.df$PrintingsList,"ATH") >= 1),
                 y1999 = as.numeric(str_count(MTG.df$PrintingsList,"ULG") >= 1|
                                   str_count(MTG.df$PrintingsList,"6ED") >= 1|
                                   str_count(MTG.df$PrintingsList,"UDS") >= 1|
                                   str_count(MTG.df$PrintingsList,"PTK") >= 1|
                                   str_count(MTG.df$PrintingsList,"S99") >= 1|
                                   str_count(MTG.df$PrintingsList,"MMQ") >= 1|
                                   str_count(MTG.df$PrintingsList,"BRB") >= 1),
                 y2000 = as.numeric(str_count(MTG.df$PrintingsList,"NEM") >= 1|
                                   str_count(MTG.df$PrintingsList,"S00") >= 1|
                                   str_count(MTG.df$PrintingsList,"PCY") >= 1|
                                   str_count(MTG.df$PrintingsList,"INV") >= 1|
                                   str_count(MTG.df$PrintingsList,"BTD") >= 1),
                 y2001 = as.numeric(str_count(MTG.df$PrintingsList,"PLS") >= 1|
                                   str_count(MTG.df$PrintingsList,"7ED") >= 1|
                                   str_count(MTG.df$PrintingsList,"APC") >= 1|
                                   str_count(MTG.df$PrintingsList,"ODY") >= 1|
                                   str_count(MTG.df$PrintingsList,"DKM") >= 1),
                 y2002 = as.numeric(str_count(MTG.df$PrintingsList,"TOR") >= 1|
                                   str_count(MTG.df$PrintingsList,"JUD") >= 1|
                                   str_count(MTG.df$PrintingsList,"ONS") >= 1),
                 y2003 = as.numeric(str_count(MTG.df$PrintingsList,"LGN") >= 1|
                                   str_count(MTG.df$PrintingsList,"SCG") >= 1|
                                   str_count(MTG.df$PrintingsList,"8ED") >= 1|
                                   str_count(MTG.df$PrintingsList,"MRD") >= 1),
                 y2004 = as.numeric(str_count(MTG.df$PrintingsList,"DST") >= 1|
                                   str_count(MTG.df$PrintingsList,"5DN") >= 1|
                                   str_count(MTG.df$PrintingsList,"CHK") >= 1|
                                   str_count(MTG.df$PrintingsList,"UNH") >= 1),
                 y2005 = as.numeric(str_count(MTG.df$PrintingsList,"BOK") >= 1|
                                   str_count(MTG.df$PrintingsList,"SOK") >= 1|
                                   str_count(MTG.df$PrintingsList,"9ED") >= 1|
                                   str_count(MTG.df$PrintingsList,"RAV") >= 1),
                 y2006 = as.numeric(str_count(MTG.df$PrintingsList,"GPT") >= 1|
                                   str_count(MTG.df$PrintingsList,"DIS") >= 1|
                                   str_count(MTG.df$PrintingsList,"CSP") >= 1|
                                   str_count(MTG.df$PrintingsList,"TSP") >= 1),
                 y2007 = as.numeric(str_count(MTG.df$PrintingsList,"PLC") >= 1|
                                   str_count(MTG.df$PrintingsList,"FUT") >= 1|
                                   str_count(MTG.df$PrintingsList,"10E") >= 1|
                                   str_count(MTG.df$PrintingsList,"MED") >= 1|
                                   str_count(MTG.df$PrintingsList,"LRW") >= 1|
                                   str_count(MTG.df$PrintingsList,"EVG") >= 1),
                 y2008 = as.numeric(str_count(MTG.df$PrintingsList,"MOR") >= 1|
                                   str_count(MTG.df$PrintingsList,"SHM") >= 1|
                                   str_count(MTG.df$PrintingsList,"EVE") >= 1|
                                   str_count(MTG.df$PrintingsList,"DRB") >= 1|
                                   str_count(MTG.df$PrintingsList,"ME2") >= 1|
                                   str_count(MTG.df$PrintingsList,"ALA") >= 1|
                                   str_count(MTG.df$PrintingsList,"DD2") >= 1),
                 y2009 = as.numeric(str_count(MTG.df$PrintingsList,"CON") >= 1|
                                   str_count(MTG.df$PrintingsList,"DDC") >= 1|
                                   str_count(MTG.df$PrintingsList,"ARB") >= 1|
                                   str_count(MTG.df$PrintingsList,"M10") >= 1|
                                   str_count(MTG.df$PrintingsList,"TD0") >= 1|
                                   str_count(MTG.df$PrintingsList,"V09") >= 1|
                                   str_count(MTG.df$PrintingsList,"HOP") >= 1|
                                   str_count(MTG.df$PrintingsList,"ME3") >= 1|
                                   str_count(MTG.df$PrintingsList,"ZEN") >= 1|
                                   str_count(MTG.df$PrintingsList,"DDD") >= 1|
                                   str_count(MTG.df$PrintingsList,"H09") >= 1),
                 y2010 = as.numeric(str_count(MTG.df$PrintingsList,"WWK") >= 1|
                                   str_count(MTG.df$PrintingsList,"DDE") >= 1|
                                   str_count(MTG.df$PrintingsList,"ROE") >= 1|
                                   str_count(MTG.df$PrintingsList,"DPA") >= 1|
                                   str_count(MTG.df$PrintingsList,"ARC") >= 1|
                                   str_count(MTG.df$PrintingsList,"M11") >= 1|
                                   str_count(MTG.df$PrintingsList,"V10") >= 1|
                                   str_count(MTG.df$PrintingsList,"DDF") >= 1|
                                   str_count(MTG.df$PrintingsList,"SOM") >= 1|
                                   str_count(MTG.df$PrintingsList,"TD0") >= 1|
                                   str_count(MTG.df$PrintingsList,"PD2") >= 1),
                 y2011 = as.numeric(str_count(MTG.df$PrintingsList,"ME4") >= 1|
                                   str_count(MTG.df$PrintingsList,"MBS") >= 1|
                                   str_count(MTG.df$PrintingsList,"DDG") >= 1|
                                   str_count(MTG.df$PrintingsList,"NPH") >= 1|
                                   str_count(MTG.df$PrintingsList,"CMD") >= 1|
                                   str_count(MTG.df$PrintingsList,"M12") >= 1|
                                   str_count(MTG.df$PrintingsList,"V11") >= 1|
                                   str_count(MTG.df$PrintingsList,"DDH") >= 1|
                                   str_count(MTG.df$PrintingsList,"ISD") >= 1|
                                   str_count(MTG.df$PrintingsList,"PD3") >= 1),
                 y2012 = as.numeric(str_count(MTG.df$PrintingsList,"DKA") >= 1|
                                   str_count(MTG.df$PrintingsList,"DDI") >= 1|
                                   str_count(MTG.df$PrintingsList,"AVR") >= 1|
                                   str_count(MTG.df$PrintingsList,"PC2") >= 1|
                                   str_count(MTG.df$PrintingsList,"M13") >= 1|
                                   str_count(MTG.df$PrintingsList,"V12") >= 1|
                                   str_count(MTG.df$PrintingsList,"DDJ") >= 1|
                                   str_count(MTG.df$PrintingsList,"RTR") >= 1|
                                   str_count(MTG.df$PrintingsList,"CM1") >= 1),
                 y2013 = as.numeric(str_count(MTG.df$PrintingsList,"TD2") >= 1|
                                   str_count(MTG.df$PrintingsList,"GTC") >= 1|
                                   str_count(MTG.df$PrintingsList,"DDK") >= 1|
                                   str_count(MTG.df$PrintingsList,"DGM") >= 1|
                                   str_count(MTG.df$PrintingsList,"MMA") >= 1|
                                   str_count(MTG.df$PrintingsList,"M14") >= 1|
                                   str_count(MTG.df$PrintingsList,"V13") >= 1|
                                   str_count(MTG.df$PrintingsList,"DDL") >= 1|
                                   str_count(MTG.df$PrintingsList,"THS") >= 1|
                                   str_count(MTG.df$PrintingsList,"C13") >= 1),
                 y2014 = as.numeric(str_count(MTG.df$PrintingsList,"BNG") >= 1|
                                   str_count(MTG.df$PrintingsList,"DDM") >= 1|
                                   str_count(MTG.df$PrintingsList,"JOU") >= 1|
                                   str_count(MTG.df$PrintingsList,"MD1") >= 1|
                                   str_count(MTG.df$PrintingsList,"CNS") >= 1|
                                   str_count(MTG.df$PrintingsList,"VMA") >= 1|
                                   str_count(MTG.df$PrintingsList,"M15") >= 1|
                                   str_count(MTG.df$PrintingsList,"V14") >= 1|
                                   str_count(MTG.df$PrintingsList,"DDN") >= 1|
                                   str_count(MTG.df$PrintingsList,"KTK") >= 1|
                                   str_count(MTG.df$PrintingsList,"C14") >= 1|
                                   str_count(MTG.df$PrintingsList,"DD3") >= 1),
                 y2015 = as.numeric(str_count(MTG.df$PrintingsList,"FRF") >= 1|
                                   str_count(MTG.df$PrintingsList,"DDO") >= 1|
                                   str_count(MTG.df$PrintingsList,"DTK") >= 1|
                                   str_count(MTG.df$PrintingsList,"TPR") >= 1|
                                   str_count(MTG.df$PrintingsList,"MM2") >= 1|
                                   str_count(MTG.df$PrintingsList,"ORI") >= 1|
                                   str_count(MTG.df$PrintingsList,"V15") >= 1|
                                   str_count(MTG.df$PrintingsList,"DDP") >= 1|
                                   str_count(MTG.df$PrintingsList,"BFZ") >= 1|
                                   str_count(MTG.df$PrintingsList,"EXP") >= 1|
                                   str_count(MTG.df$PrintingsList,"C15") >= 1|
                                   str_count(MTG.df$PrintingsList,"PZ1") >= 1),
                 y2016 = as.numeric(str_count(MTG.df$PrintingsList,"EXP") >= 1|
                                   str_count(MTG.df$PrintingsList,"OGW") >= 1|
                                   str_count(MTG.df$PrintingsList,"DDQ") >= 1|
                                   str_count(MTG.df$PrintingsList,"W16") >= 1|
                                   str_count(MTG.df$PrintingsList,"SOI") >= 1|
                                   str_count(MTG.df$PrintingsList,"EMA") >= 1|
                                   str_count(MTG.df$PrintingsList,"EMN") >= 1|
                                   str_count(MTG.df$PrintingsList,"V16") >= 1|
                                   str_count(MTG.df$PrintingsList,"CN2") >= 1|
                                   str_count(MTG.df$PrintingsList,"DDR") >= 1|
                                   str_count(MTG.df$PrintingsList,"KLD") >= 1|
                                   str_count(MTG.df$PrintingsList,"MPS") >= 1|
                                   str_count(MTG.df$PrintingsList,"PZ2") >= 1|
                                   str_count(MTG.df$PrintingsList,"C16") >= 1|
                                   str_count(MTG.df$PrintingsList,"PCA") >= 1),
                 y2017 = as.numeric(str_count(MTG.df$PrintingsList,"MPS") >= 1|
                                   str_count(MTG.df$PrintingsList,"AER") >= 1|
                                   str_count(MTG.df$PrintingsList,"MM3") >= 1|
                                   str_count(MTG.df$PrintingsList,"DDS") >= 1|
                                   str_count(MTG.df$PrintingsList,"W17") >= 1|
                                   str_count(MTG.df$PrintingsList,"AKH") >= 1|
                                   str_count(MTG.df$PrintingsList,"MPS") >= 1|
                                   str_count(MTG.df$PrintingsList,"CMA") >= 1|
                                   str_count(MTG.df$PrintingsList,"E01") >= 1|
                                   str_count(MTG.df$PrintingsList,"HOU") >= 1|
                                   str_count(MTG.df$PrintingsList,"C17") >= 1|
                                   str_count(MTG.df$PrintingsList,"XLN") >= 1|
                                   str_count(MTG.df$PrintingsList,"DDT") >= 1|
                                   str_count(MTG.df$PrintingsList,"IMA") >= 1|
                                   str_count(MTG.df$PrintingsList,"E02") >= 1|
                                   str_count(MTG.df$PrintingsList,"V17") >= 1|
                                   str_count(MTG.df$PrintingsList,"UST") >= 1),
                 y2018 = as.numeric(str_count(MTG.df$PrintingsList,"RIX") >= 1|
                                   str_count(MTG.df$PrintingsList,"A25") >= 1|
                                   str_count(MTG.df$PrintingsList,"DOM") >= 1|
                                   str_count(MTG.df$PrintingsList,"M19") >= 1))
     # No observations in 2018, but we included it anyway
```
The character variable Text, as it is, is not helpful for algorithmically predicting Color Identity. We decided to count words in Text relevant to each color using Mark Rosewater's "Mechanical Color Pie 2017" as a guide. Below find the summation of words related to the color white as an example:
```{r colorWordsEx}
MTG.df <- mutate(MTG.df, WhiteWords= 0+stri_count(MTG.df$Text,regex="(exile(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(prevent(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(defender(?![^\\(]*\\\\))") + 
                   stri_count(MTG.df$Text,regex="(attacking or blocking(?![^\\(]*\\\\))") + 
                   stri_count(MTG.df$Text,regex="(blocking or attacking(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(double strike(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(first strike(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(aura(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(enchantment(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(flying(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(indestructible(?![^\\(]*\\\\))") + 
                   stri_count(MTG.df$Text,regex="(lifelink(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(protection(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(token(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(vigilance(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(destroy all creatures(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(tap target(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(\\-\\d\\/\\+\\d(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(\\+0\\/\\+\\d(?![^\\(]*\\\\))")+
                   # Mark Rosewater says the above attributes are primary in White
                   .5*(stri_count(MTG.df$Text,regex="(destroy target artifact(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(return(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(graveyard(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(scry(?![^\\(]*\\\\))")+   
                   stri_count(MTG.df$Text,regex="(\\+\\d\\/\\+\\d(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(\\+\\d\\/\\+0(?![^\\(]*\\\\))"))+
                   # Secondary in white; assign them half a word
                   .15*(stri_count(MTG.df$Text,regex="(each basic land(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(flash(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(hexproof(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(counter(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(reach(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(trample(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(\\-\\d\\/\\-\\d(?![^\\(]*\\\\))")))
                   # Tertiary in White; assign .15 of a word
MTG.df$WhiteWords[is.na(MTG.df$WhiteWords)] <- 0
# The regex (blah(?![^(]*\\)) matches all blah outside parentheses.
# This lets the code ignore 'reminder text,' text in parentheses.
# The regex (\\-\\d\\/\\+\\d(?![^\\(]*\\\\))) matches all -a/+b where a, b are digits
# We performed a similar process with every other color
```

```{r colorWords, include=FALSE}
MTG.df <- mutate(MTG.df, BlueWords= 0+stri_count(MTG.df$Text,regex="(return(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(draw(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(can't be blocked(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(copy(?![^\\(]*\\\\))") + 
                   stri_count(MTG.df$Text,regex="(counter(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(flash(?![^\\(]*\\\\))") + 
                   stri_count(MTG.df$Text,regex="(flying(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(under its owner's control(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(doesn't untap during(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(hexproof(?![^\\(]*\\\\))") + 
                   stri_count(MTG.df$Text,regex="(scry(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(top \\S cards from his or her library into his or her graveyard(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(tap or untap(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(untap(?![^\\(]*\\\\))") + 
                   stri_count(MTG.df$Text,regex="(\\-\\d\\/\\+\\d(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(\\+\\d\\/\\-\\d(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(\\-\\d\\/\\-0(?![^\\(]*\\\\))")+
                   .5*(stri_count(MTG.df$Text,regex="(each basic land(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(token(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(exile(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(can't be countered(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(defender(?![^\\(]*\\\\))")+   
                   stri_count(MTG.df$Text,regex="(\\+\\d\\/\\+\\d(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(\\+0\\/\\+\\d(?![^\\(]*\\\\))"))+
                   .15*(stri_count(MTG.df$Text,regex="(indestructible(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(protection(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(trample(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(\\+\\d\\/\\+0(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(\\-\\d\\/\\-\\d(?![^\\(]*\\\\))"))) 
MTG.df$BlueWords[is.na(MTG.df$BlueWords)] <- 0

MTG.df <- mutate(MTG.df, BlackWords = 0 +
                   stri_count(MTG.df$Text,regex="(sacrifice(?![^\\(]*\\\\))") + 
                   stri_count(MTG.df$Text,regex="(deathtouch(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(destroy(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(discard(?![^\\(]*\\\\))") + 
                   stri_count(MTG.df$Text,regex="(gain control(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(whenever another creature dies(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(menace(?![^\\(]*\\\\))") + 
                   stri_count(MTG.df$Text,regex="(search(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(graveyard(?![^\\(]*\\\\))") + 
                   stri_count(MTG.df$Text,regex="(\\+\\d\\/\\+\\d(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(\\-\\d\\/\\-\\d(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(\\+\\d\\/\\-\\d(?![^\\(]*\\\\))")+
                   .5*(stri_count(MTG.df$Text,regex="(draw(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(token(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(destroy all creatures(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(defender(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(deal \\d damage(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(flying(?![^\\(]*\\\\))")+   
                   stri_count(MTG.df$Text,regex="(haste(?![^\\(]*\\\\))")+   
                   stri_count(MTG.df$Text,regex="(indestructible(?![^\\(]*\\\\))")+   
                   stri_count(MTG.df$Text,regex="(lifelink(?![^\\(]*\\\\))")+   
                   stri_count(MTG.df$Text,regex="(scry(?![^\\(]*\\\\))")+   
                   stri_count(MTG.df$Text,regex="(\\+\\d\\/\\+0(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(\\-\\d\\/\\-0(?![^\\(]*\\\\))"))+
                   .15*(stri_count(MTG.df$Text,regex="(first strike(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(flash(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(protection(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(trample(?![^\\(]*\\\\))")))
MTG.df$BlackWords[is.na(MTG.df$BlackWords)] <- 0

MTG.df <- mutate(MTG.df, RedWords = 0 +
                   stri_count(MTG.df$Text,regex="(can't be countered(?![^\\(]*\\\\))") + 
                   stri_count(MTG.df$Text,regex="(copy(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(deal \\d damage(?![^\\(]*\\\\))") + 
                   stri_count(MTG.df$Text,regex="(deal damage(?![^\\(]*\\\\))") + 
                   stri_count(MTG.df$Text,regex="(double strike(?![^\\(]*\\\\))") + 
                   stri_count(MTG.df$Text,regex="(first strike(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(combat phase(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(haste(?![^\\(]*\\\\))") + 
                   stri_count(MTG.df$Text,regex="(menace(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(if able(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(must(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(destroy target artifact(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(destroy target land(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(tap target land(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(random(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(attack(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(\\+\\d\\/\\+0(?![^\\(]*\\\\))")+
                   .5*(stri_count(MTG.df$Text,regex="(token(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(return(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(can't block(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(draw(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(defender(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(flying(?![^\\(]*\\\\))")+   
                   stri_count(MTG.df$Text,regex="(prowess(?![^\\(]*\\\\))")+   
                   stri_count(MTG.df$Text,regex="(reach(?![^\\(]*\\\\))")+   
                   stri_count(MTG.df$Text,regex="(scry(?![^\\(]*\\\\))")+   
                   stri_count(MTG.df$Text,regex="(\\+\\d\\/\\+\\d(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(\\+\\d\\/\\-\\d(?![^\\(]*\\\\))"))+
                   .15*(
                   stri_count(MTG.df$Text,regex="(indestructible(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(flash(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(protection(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(\\-\\d\\/\\-\\d(?![^\\(]*\\\\))")))
MTG.df$RedWords[is.na(MTG.df$RedWords)] <- 0

MTG.df <- mutate(MTG.df, GreenWords = 0+
                   stri_count(MTG.df$Text,regex="(can't be countered(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(destroy target artifact(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(destroy target enchantment(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(destroy target creature with flying(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(fight(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(deals damage equal to its power(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(reach(?![^\\(]*\\\\))") + 
                   stri_count(MTG.df$Text,regex="(trample(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(each creature(?![^\\(]*\\\\))") + 
                   stri_count(MTG.df$Text,regex="(forest(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(each land(?![^\\(]*\\\\))") + 
                   stri_count(MTG.df$Text,regex="(token(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(\\+\\d\\/\\+\\d(?![^\\(]*\\\\))") + 
                   .5*(stri_count(MTG.df$Text,regex="(exile(?![^\\(]*\\\\))") +
                   stri_count(MTG.df$Text,regex="(draw(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(deathtouch(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(defender(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(flash(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(must block(?![^\\(]*\\\\))")+   
                   stri_count(MTG.df$Text,regex="(hexproof(?![^\\(]*\\\\))")+   
                   stri_count(MTG.df$Text,regex="(indestructible(?![^\\(]*\\\\))")+   
                   stri_count(MTG.df$Text,regex="(vigilance(?![^\\(]*\\\\))")+   
                   stri_count(MTG.df$Text,regex="(scry(?![^\\(]*\\\\))")+   
                   stri_count(MTG.df$Text,regex="(\\+0\\/\\+\\d(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(\\+\\d\\/\\+0(?![^\\(]*\\\\))"))+
                   .15*(
                   stri_count(MTG.df$Text,regex="(flying(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(haste(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(protection(?![^\\(]*\\\\))")+
                   stri_count(MTG.df$Text,regex="(\\-\\d\\/\\-\\d(?![^\\(]*\\\\))")))
MTG.df$GreenWords[is.na(MTG.df$GreenWords)] <- 0
```
Some of these words are related to more than one color. Nevertheless, they are invaluable in classification. Observe the following:
```{r identityByWords}
table(MTG.df[MTG.df$WhiteWords>=1,]$ColorIdentity) # Prints the number of cards with
                                                   # one white word, by color identity
```
Cards with at least one White word are more likely to have White (W) in their Color Identity, even if the correlation is slight. This suggests that our White keywords are well-chosen for analysing Color Identity.

Now let us divide the data into training and test sets. 
```{r dataSplitting}
rares <- MTG.df[MTG.df$Power %in%
                  c("-1",".5","1.5","1+*","2.5","3.5","11","12","13","15","99"),]
rares <- rbind(rares,MTG.df[MTG.df$Toughness %in%
                  c("-1",".5","1.5","1+*","2.5","3.5","7-*","11","12","13","14","15","99"),])
rares <- rbind(rares,MTG.df[MTG.df$ColorIdentity %in%
                  c("WUBR","WUBG","WURG","WBRG","UBRG","WUBRG","WUR","WBG","UBG"),])
rares <- rbind(rares,MTG.df[MTG.df$ConvertedManaCost %in%
                  c(10,11,12,13,14,15,16,100000),])
rares <- rbind(rares,MTG.df[MTG.df$Loyalty %in%
                  c(2,3,4,5,6,7),])
     # We should make sure our training set includes these niche values

set.seed(999)
train = sample(1:nrow(MTG.df),7000)  # Choose 7000 random cards for training
MTG.train <- MTG.df[train,]
MTG.train <- rbind(MTG.train,rares)  # Add niche values
MTG.train <- unique(MTG.train)       # Remove duplicates
MTG.test <- MTG.df[-train,]          # Test data includes some niche values from training
```
Before we make a random forest which predicts whether White (W) is in a card's Color Identity, we should perform a 'sanity check' by observing whether a single helpful tree can be made:
```{r WhiteTree}
MTG.White <- select(MTG.train, -c(Name,Supertype,Type,Subtype,Text,PrintingsList,Loyalty,
                        65:90))%>% mutate(ColorIdentity = str_count(ColorIdentity,"W"))
WhiteTree <- tree(ColorIdentity~.,
                  data=MTG.White,control=tree.control(nrow(MTG.train),mindev=.008,minsize=2))
draw.tree(WhiteTree,nodeinfo=FALSE)
```
With only a few decisions, we may give a percentage chance a card has White (W) in its Color Identity using some easily understood metrics. For example, if a card is not a soldier, cleric, or angel and it has more than one white word, but less than .225 blue words, we give it a 45.86% percent chance to have White in its Color Identity. We made similar trees for each color, and you can view them in the RMD, but we decided not to include them in the PDF for space considerations. We notice that subtypes are consistantly early splits, suggesting high explanatory power; soldiers are usually white, wizards are usually blue, zombies are usually black, and so on.
```{r BlueTree, include=FALSE}
MTG.Blue <- select(MTG.train,-c(Name,Supertype,Type,Subtype,Text,PrintingsList,Loyalty,
                                 65:90)) %>% 
                        mutate(ColorIdentity = str_count(ColorIdentity,"U"))
BlueTree <- tree(ColorIdentity~.,data=MTG.Blue,control=tree.control(nrow(MTG.train),mindev=.008,minsize=2))
draw.tree(BlueTree,nodeinfo=FALSE)
```

```{r BlackTree, include=FALSE}
MTG.Black <- select(MTG.train,-c(Name,Supertype,Type,Subtype,Text,PrintingsList,Loyalty,
                                 65:90)) %>% 
                        mutate(ColorIdentity = str_count(ColorIdentity,"B"))
BlackTree <- tree(ColorIdentity~.,
                  data=MTG.Black,control=tree.control(nrow(MTG.train),mindev=.008,minsize=2))
draw.tree(BlackTree,nodeinfo=FALSE)
```

```{r RedTree,include=FALSE}
MTG.Red <- select(MTG.train,-c(Name,Supertype,Type,Subtype,Text,PrintingsList,Loyalty,
                                 65:90)) %>% 
                        mutate(ColorIdentity = str_count(ColorIdentity,"R"))
RedTree <- tree(ColorIdentity~.,data=MTG.Red,control=tree.control(nrow(MTG.train),mindev=.008,minsize=2))
draw.tree(RedTree,nodeinfo=FALSE)
```

```{r GreenTree, include=FALSE}
MTG.Green <- select(MTG.train,-c(Name,Supertype,Type,Subtype,Text,PrintingsList,Loyalty,
                                 65:90)) %>% 
                        mutate(ColorIdentity = str_count(ColorIdentity,"G"))
GreenTree <- tree(ColorIdentity~.,
                  data=MTG.Green,control=tree.control(nrow(MTG.train),mindev=.008,minsize=2))
draw.tree(GreenTree,nodeinfo=FALSE)
```
Feeling justified in the use of decision trees for Color Identity classification, we set to work defining a quintet of Random Forests. 
```{r randomforestWhite,cache=TRUE}
set.seed(1)
MTG.White[sapply(MTG.White, is.character)] <- 
  lapply(MTG.White[sapply(MTG.White, is.character)],as.factor)
White.test <- select(MTG.test,-c(Name,Supertype,Type,Subtype,Text,PrintingsList,Loyalty)) %>%  
                        mutate(ColorIdentity = str_count(ColorIdentity,"W"))
White.test[sapply(White.test, is.character)] <- 
  lapply(White.test[sapply(White.test, is.character)],as.factor)

rf.White<-randomForest(as.factor(ColorIdentity)~.,data=MTG.White,importance=TRUE)
varImpPlot(rf.White,sort=T)    # Print variable list by impact on method
```
The Mean Decrease in Accuracy generally concurs with the variable choices for splits in the example tree. The Mean Decrease in GINI has some interesting top entries including text-length.
```{r}
print(rf.White)
```
The Out-of-Box Estimate is consistently about 16% across the colors. This is encouraging, suggesting that the forests will perform well on test data.
```{r}
rf.pred=predict(rf.White,White.test)
rf.err = table(pred = rf.pred, truth = White.test$ColorIdentity) 
test.rf.err = 1 - sum(diag(rf.err))/sum(rf.err)
test.rf.err # Test error for the random forest

tree.pred = predict(WhiteTree, White.test)
tree.err=table(pred=tree.pred,truth=White.test$ColorIdentity)
test.tree.err=1 - sum(diag(tree.err))/sum(tree.err)
test.tree.err # Test error for the example tree alone
```
This random forest has much lower test error than the example tree on its own. We made a similar random forest for every color, each one drastically reducing the test error of its related tree.
```{r randomforestBlue,cache=TRUE,include=FALSE}
MTG.Blue <- select(MTG.train,-c(Name,Supertype,Type,Subtype,Text,PrintingsList,Loyalty,
                                65:90)) %>%  
                        mutate(ColorIdentity = str_count(ColorIdentity,"U"))

set.seed(1)
MTG.Blue[sapply(MTG.Blue, is.character)] <- 
  lapply(MTG.Blue[sapply(MTG.Blue, is.character)],as.factor)
Blue.test <- select(MTG.test,-c(Name,Supertype,Type,Subtype,Text,PrintingsList,Loyalty)) %>%  
                        mutate(ColorIdentity = str_count(ColorIdentity,"U"))
Blue.test[sapply(Blue.test, is.character)] <- 
  lapply(Blue.test[sapply(Blue.test, is.character)],as.factor)

rf.blue<-randomForest(as.factor(ColorIdentity)~.,data=MTG.Blue,importance=TRUE)
varImpPlot(rf.blue,sort=T)
print(rf.blue)

rf.pred=predict(rf.blue,Blue.test)
rf.err = table(pred = rf.pred, truth = Blue.test$ColorIdentity) 
test.rf.err = 1 - sum(diag(rf.err))/sum(rf.err)
test.rf.err #seems like RF has a smaller test error again

tree.pred = predict(BlueTree, Blue.test)
tree.err=table(pred=tree.pred,truth=Blue.test$ColorIdentity)
test.tree.err=1 - sum(diag(tree.err))/sum(tree.err)
test.tree.err
```

```{r randomforestBlack,cache=TRUE,include=FALSE}
MTG.Black <- select(MTG.train,-c(Name,Supertype,Type,Subtype,Text,PrintingsList,Loyalty,
                                65:90)) %>%  
                        mutate(ColorIdentity = str_count(ColorIdentity,"B"))

set.seed(1)
MTG.Black[sapply(MTG.Black, is.character)] <- 
  lapply(MTG.Black[sapply(MTG.Black, is.character)],as.factor)
Black.test <- select(MTG.test,-c(Name,Supertype,Type,Subtype,Text,PrintingsList,Loyalty)) %>%  
                        mutate(ColorIdentity = str_count(ColorIdentity,"B"))
Black.test[sapply(Black.test, is.character)] <- 
  lapply(Black.test[sapply(Black.test, is.character)],as.factor)

rf.Black<-randomForest(as.factor(ColorIdentity)~.,data=MTG.Black,importance=TRUE)

varImpPlot(rf.Black,sort=T)
print(rf.Black)

rf.pred=predict(rf.Black,Black.test)
rf.err = table(pred = rf.pred, truth = Black.test$ColorIdentity) 
test.rf.err = 1 - sum(diag(rf.err))/sum(rf.err)
test.rf.err #seems like RF has a smaller test error again

tree.pred = predict(BlackTree, Black.test)
tree.err=table(pred=tree.pred,truth=Black.test$ColorIdentity)
test.tree.err=1 - sum(diag(tree.err))/sum(tree.err)
test.tree.err
```

```{r randomforestRed,cache=TRUE,include=FALSE}
MTG.Red <- select(MTG.train,-c(Name,Supertype,Type,Subtype,Text,PrintingsList,Loyalty,
                                65:90)) %>%  
                        mutate(ColorIdentity = str_count(ColorIdentity,"R"))

set.seed(1)
MTG.Red[sapply(MTG.Red, is.character)] <- lapply(MTG.Red[sapply(MTG.Red, is.character)], 
                                       as.factor)
Red.test <- select(MTG.test,-c(Name,Supertype,Type,Subtype,Text,PrintingsList,Loyalty)) %>%  
                        mutate(ColorIdentity = str_count(ColorIdentity,"R"))
Red.test[sapply(Red.test, is.character)] <- lapply(Red.test[sapply(Red.test, is.character)], 
                                       as.factor)
rf.Red<-randomForest(as.factor(ColorIdentity)~.,data=MTG.Red,importance=TRUE)
varImpPlot(rf.Red,sort=T)
print(rf.Red)

rf.pred=predict(rf.Red,Red.test)
rf.err = table(pred = rf.pred, truth = Red.test$ColorIdentity) 
test.rf.err = 1 - sum(diag(rf.err))/sum(rf.err)
test.rf.err #seems like RF has a smaller test error again

tree.pred = predict(RedTree, Red.test)
tree.err=table(pred=tree.pred,truth=Red.test$ColorIdentity)
test.tree.err=1 - sum(diag(tree.err))/sum(tree.err)
test.tree.err
```

```{r randomforestGreen,cache=TRUE,include=FALSE}
MTG.Green <- select(MTG.train,-c(Name,Supertype,Type,Subtype,Text,PrintingsList,Loyalty,
                                65:90)) %>%  
                        mutate(ColorIdentity = str_count(ColorIdentity,"G"))

set.seed(1)
MTG.Green[sapply(MTG.Green, is.character)] <- lapply(MTG.Green[sapply(MTG.Green, is.character)], 
                                       as.factor)
Green.test <- select(MTG.test,-c(Name,Supertype,Type,Subtype,Text,PrintingsList,Loyalty)) %>%  
                        mutate(ColorIdentity = str_count(ColorIdentity,"G"))
Green.test[sapply(Green.test, is.character)] <- lapply(Green.test[sapply(Green.test, is.character)], 
                                       as.factor)
rf.Green<-randomForest(as.factor(ColorIdentity)~.,data=MTG.Green,importance=TRUE)
varImpPlot(rf.Green,sort=T)
print(rf.Green)

rf.pred=predict(rf.Green,Green.test)
rf.err = table(pred = rf.pred, truth = Green.test$ColorIdentity) 
test.rf.err = 1 - sum(diag(rf.err))/sum(rf.err)
test.rf.err #seems like RF has a smaller test error again

tree.pred = predict(GreenTree, Green.test)
tree.err=table(pred=tree.pred,truth=Green.test$ColorIdentity)
test.tree.err=1 - sum(diag(tree.err))/sum(tree.err)
test.tree.err
```
Now we have five random forests which give probabilities that each of the five colors is present in a card's Color Identity. We may combine their output to predict a card's precise identity.
```{r guesses}
guesses <- data.frame(matrix(ncol=6,nrow=nrow(MTG.train)))
guesses[,1] <- MTG.train$ColorIdentity
guesses[,2] <- predict(rf.White,MTG.White,type="prob")[,2]
guesses[,3] <- predict(rf.blue,MTG.Blue,type="prob")[,2]
guesses[,4] <- predict(rf.Black,MTG.Black,type="prob")[,2]
guesses[,5] <- predict(rf.Red,MTG.Red,type="prob")[,2]
guesses[,6] <- predict(rf.Green,MTG.Green,type="prob")[,2]
     # guesses contains the true training color identities and 
     # proportion of trees in each forest declaring a card each color.

guesses <- setNames(guesses,c("ColorIdentity","probWhite","probBlue",
                              "probBlack","probRed","probGreen")) 

guesses <- transmute(guesses, ColorIdentity=as.factor(ColorIdentity),
                     probWhite=as.double(probWhite),
                     probBlue=as.double(probBlue),
                     probBlack=as.double(probBlack),
                     probRed=as.double(probRed),
                     probGreen=as.double(probGreen))
guesses$ColorIdentity[guesses$ColorIdentity==""] <- "C"

rf.final<-randomForest(ColorIdentity~.,data=guesses,importance=TRUE)
     # New random forest trained on guesses

final.test <- select(MTG.test,-c(Name,Supertype,Type,Subtype,Text,PrintingsList,Loyalty))
     # Prepare test data

TestGuesses <- data.frame(matrix(ncol=6,nrow=nrow(final.test)))
TestGuesses[,1] <- final.test$ColorIdentity
TestGuesses[,2] <- predict(rf.White,final.test,type="prob")[,2]
TestGuesses[,3] <- predict(rf.blue,final.test,type="prob")[,2]
TestGuesses[,4] <- predict(rf.Black,final.test,type="prob")[,2]
TestGuesses[,5] <- predict(rf.Red,final.test,type="prob")[,2]
TestGuesses[,6] <- predict(rf.Green,final.test,type="prob")[,2]
     # contains the true test color identities and 
     # proportion of trees in each forest declaring a card each color. 

TestGuesses <- setNames(TestGuesses,c("ColorIdentity","probWhite","probBlue",
                              "probBlack","probRed","probGreen")) 

TestGuesses <- transmute(TestGuesses, ColorIdentity=as.factor(ColorIdentity),
                     probWhite=as.double(probWhite),
                     probBlue=as.double(probBlue),
                     probBlack=as.double(probBlack),
                     probRed=as.double(probRed),
                     probGreen=as.double(probGreen))
TestGuesses$ColorIdentity[TestGuesses$ColorIdentity==""] <- "C"

rf.pred=predict(rf.final,TestGuesses) # Predict test data
rf.err = table(pred = rf.pred, truth = MTG.test$ColorIdentity) 
(test.rf.err = 1 - sum(diag(rf.err))/sum(rf.err)) # Test error of the compound model
rf.err # Large confusion matrix
```
The test error seems unreasonably high at .569. If given 100 random cards, we would expect only 43 of them to be sorted correctly. However, looking at the confusion matrix, we understand how harshly the algorithm is being measured. If a card's Color Identity is $WUB$ and the random forest suggests $WU$, it seems unfair to declare its answer totally incorrect. Therefore, we use Hamming distance to assess the difference between our predictions and the actual test values. First we need to write the Color Identities as uniform strings so they may be meaningfully compared: 
```{r,results="hide"}
rf.comparison <- data.frame(matrix(ncol=4,nrow=nrow(MTG.test)))
rf.comparison <- setNames(rf.comparison,c("Name","Distance","Predicted","Actual")) 

rf.comparison$Name <- MTG.test$Name
rf.comparison$Predicted <- rf.pred
rf.comparison$Actual <- MTG.test$ColorIdentity

rf.comparison[,3] <- mapvalues(rf.comparison[,3],from=c("C","W","U","B","R","G", 
"WU","WB","WR","WG","UB","UR","UG","BR","BG","RG","WUB","WUR","WUG","WBR",
"WBG","WRG","UBR","UBG", "URG","BRG","WUBR", "WUBG","WURG","WBRG", "UBRG","WUBRG"),to=c("_____","W____","_U___","__B__","___R_","____G",
                        "WU___","W_B__","W__R_","W___G","_UB__","_U_R_","_U___G","__BR_",
                        "__B_G","___RG","WUB__","WU_R_","WU__G","W_BR_","W_B_G","W__RG","_UBR_",
                        "_UB_G", "_U_RG","__BRG","WUBR_", "WUB_G","WU_RG","W_BRG",
                        "_UBRG","WUBRG"))

rf.comparison[,4] <- mapvalues(rf.comparison[,4],from=c("C","W","U","B","R","G", 
"WU","WB","WR","WG","UB","UR","UG","BR","BG","RG","WUB","WUR","WUG","WBR",
"WBG","WRG","UBR","UBG", "URG","BRG","WUBR", "WUBG","WURG","WBRG", "UBRG","WUBRG"),to=c("_____","W____","_U___","__B__","___R_","____G",
                        "WU___","W_B__","W__R_","W___G","_UB__","_U_R_","_U___G","__BR_",
                        "__B_G","___RG","WUB__","WU_R_","WU__G","W_BR_","W_B_G","W__RG","_UBR_",
                        "_UB_G", "_U_RG","__BRG","WUBR_", "WUB_G","WU_RG","W_BRG",
                        "_UBRG","WUBRG"))
```
Now, finding the error:
```{r}
rf.comparison$Distance <- stringdist(rf.comparison[,3],rf.comparison[,4])
(average.error <- sum(rf.comparison$Distance)/nrow(rf.comparison))
```
On average, our quintet of random forests is wrong in its assignment of Color Identity by just under one character. By this metric, the random forest models are a moderate success.

Even though the random forest approach has a relatively high accuracy in predicting color identity of cards, we decided to use another method for comparision. Here we use logistic regressions for color prediction. 

First, we build five different fits for each color. There is a summary of logistic regression fit for white cards as an example. 
```{r logisticWhite}
set.seed(1)
glm.white = glm(as.factor(ColorIdentity) ~ ., data=MTG.White, family=binomial)
glm.red=glm(as.factor(ColorIdentity) ~ ., data=MTG.Red, family=binomial)
glm.black=glm(as.factor(ColorIdentity) ~ ., data=MTG.Black, family=binomial)
glm.blue=glm(as.factor(ColorIdentity) ~ ., data=MTG.Blue, family=binomial)
glm.green=glm(as.factor(ColorIdentity) ~ ., data=MTG.Green, family=binomial)
summary(glm.white)
```
Above we may see which factors are influential in deciding whether a card has white in its color identity or not. For example, cards with the Human subtype have 6.265e+14 added to their score because humans are likely to have White (W) in their Color Identity. Elfs have -3.779e+14 because they are more likely to be Green than White..

In order to evaluate the accuracy of these five logistic regression models, we calculate the test error rate with formula from previous homework and check the AUC value as well.
```{r whiteTest} 
calc_error_rate <- function(predicted.value, true.value){             # Calculates error
                  return(mean(true.value!=predicted.value))}          #Copy from PSTAT131 HW2 hints
prob.white = predict(glm.white, White.test,type="response") 
whitetest=as.factor(ifelse(prob.white<=0.5,0,1)) # try .5 as threshold 
print(calc_error_rate(whitetest,White.test$ColorIdentity)) 
pred = prediction(prob.white,White.test$ColorIdentity)
performance(pred, "auc")@y.values 
```
```{r bluelog}
prob.blue = predict(glm.blue, Blue.test,type="response") 
bluetest=as.factor(ifelse(prob.blue<=.5,0,1))
print(calc_error_rate(bluetest,Blue.test$ColorIdentity)) 
pred = prediction(prob.blue,Blue.test$ColorIdentity)
performance(pred, "auc")@y.values 
```
```{r redlog}
prob.red = predict(glm.red, Red.test,type="response") 
redtest=as.factor(ifelse(prob.red<=.5,0,1))
print(calc_error_rate(redtest,Red.test$ColorIdentity)) 
pred = prediction(prob.red,Red.test$ColorIdentity)
performance(pred, "auc")@y.values #AUC
```
```{r blacklog}
prob.black = predict(glm.black, Black.test,type="response") 
blacktest=as.factor(ifelse(prob.black<=.5,0,1))
print(calc_error_rate(blacktest,Black.test$ColorIdentity)) 
pred = prediction(prob.black,Black.test$ColorIdentity)
performance(pred, "auc")@y.values #get AUC
```
```{r greenlog}
prob.green = predict(glm.green, Green.test,type="response") 
greentest=as.factor(ifelse(prob.green<=.5,0,1))
print(calc_error_rate(greentest,Green.test$ColorIdentity)) 
pred = prediction(prob.green,Green.test$ColorIdentity)
performance(pred, "auc")@y.values  #AUC 
```
These values are not incredible, but they are not discouraging. We proceed to our final model using the outputs of the previous models:
```{r guesses2}
set.seed(1)
pred.white<-predict(glm.white,MTG.train,type="response")
pred.blue<-predict(glm.blue,MTG.train,type="response")
pred.black<-predict(glm.black,MTG.train,type="response")
pred.red<-predict(glm.red,MTG.train,type="response")
pred.green<-predict(glm.green,MTG.train,type="response")

guesses2 <- data.frame(matrix(ncol=6,nrow=nrow(MTG.train)))
guesses2[,1] <- MTG.train$ColorIdentity
guesses2[,2] <- exp(pred.white)/(1+exp(pred.white))
guesses2[,3] <- exp(pred.blue)/(1+exp(pred.blue))
guesses2[,4] <- exp(pred.black)/(1+exp(pred.black))
guesses2[,5] <- exp(pred.red)/(1+exp(pred.green))
guesses2[,6] <- exp(pred.green)/(1+exp(pred.green))

guesses2 <- setNames(guesses2,c("ColorIdentity","probWhite","probBlue",
                              "probBlack","probRed","probGreen")) 

guesses2 <- transmute(guesses2, ColorIdentity=as.factor(ColorIdentity),
                     probWhite=as.double(probWhite),
                     probBlue=as.double(probBlue),
                     probBlack=as.double(probBlack),
                     probRed=as.double(probRed),
                     probGreen=as.double(probGreen))
guesses2$ColorIdentity[guesses2$ColorIdentity==""] <- "C"
```
We are warned that doing prediction from a rank-deficient fit may cause our result less reliable. 

```{r finallog}
library(nnet)
set.seed(1)
glm.final = multinom(as.factor(ColorIdentity) ~ ., guesses2) #multiple classification for logistic regression
test.log <- select(MTG.test,-c(Name,Supertype,Type,Subtype,Text,PrintingsList,Loyalty))
test.pred.white<-predict(glm.white,test.log,type="response")
test.pred.blue<-predict(glm.blue,test.log,type="response")
test.pred.black<-predict(glm.black,test.log,type="response")
test.pred.red<- predict(glm.red,test.log,type="response")
test.pred.green<-predict(glm.green,test.log,type="response")

TestGuesses2 <- data.frame(matrix(ncol=6,nrow=nrow(test.log)))
TestGuesses2[,1] <- test.log$ColorIdentity
TestGuesses2[,2] <-exp(test.pred.white)/(1+exp(test.pred.white))
TestGuesses2[,3] <- exp(test.pred.blue)/(1+exp(test.pred.blue))
TestGuesses2[,4] <- exp(test.pred.black)/(1+exp(test.pred.black))
TestGuesses2[,5] <- exp(test.pred.red)/(1+exp(test.pred.red))
TestGuesses2[,6] <- exp(test.pred.green)/(1+exp(test.pred.green))

TestGuesses2 <- setNames(TestGuesses2,c("ColorIdentity","probWhite","probBlue",
                              "probBlack","probRed","probGreen")) 

TestGuesses2 <- transmute(TestGuesses2, ColorIdentity=as.factor(ColorIdentity),
                     probWhite=as.double(probWhite),
                     probBlue=as.double(probBlue),
                     probBlack=as.double(probBlack),
                     probRed=as.double(probRed),
                     probGreen=as.double(probGreen))
TestGuesses2$ColorIdentity[TestGuesses2$ColorIdentity==""] <- "C"

glm.pred = predict(glm.final,TestGuesses2)
glm.err = table(pred = glm.pred, truth = MTG.test$ColorIdentity) 
test.glm.err = 1 - sum(diag(glm.err))/sum(glm.err)
test.glm.err
glm.err
```
The error rate of 0.549 is slightly lower than for the random forests. Given 100 random cards, we would expect the logistic regression to correctly identify 45 of them as opposed to 43. We notice the logistic regression almost always chooses a single color or colorless; the top six rows of the confusion matrix account for most of the predictions. This makes the logistic regression model quite accurate on cards with no color or a single color in their Color Identity but quite inaccurate on multicolored cards.

The error rate of .549 is understandably high because, just like for the random forest approach, it is too strict when considering mixture colors. For example, if the classfier predicts "WB" while the true color is "WUB", we should not say it is compeletly wrong. Therefore,in order to consider situations when the classifier is partially correct, we use Hamming distance to assess the difference between our predictions and the actual test values for logistic case as well.
```{r}
library(stringdist)

log.comparison <- data.frame(matrix(ncol=4,nrow=nrow(MTG.test)))
log.comparison <- setNames(log.comparison,c("Name","Distance","Predicted","Actual")) 

log.comparison$Name <- MTG.test$Name
log.comparison$Predicted <- glm.pred
log.comparison$Actual <- MTG.test$ColorIdentity

log.comparison[,3] <- mapvalues(log.comparison[,3],from=c("C","W","U","B","R","G", 
"WU","WB","WR","WG","UB","UR","UG","BR","BG","RG","WUB","WUR","WUG","WBR",
"WBG","WRG","UBR","UBG", "URG","BRG","WUBR", "WUBG","WURG","WBRG", "UBRG","WUBRG"),to=c("_____","W____","_U___","__B__","___R_","____G",
                        "WU___","W_B__","W__R_","W___G","_UB__","_U_R_","_U___G","__BR_",
                        "__B_G","___RG","WUB__","WU_R_","WU__G","W_BR_","W_B_G","W__RG","_UBR_",
                        "_UB_G", "_U_RG","__BRG","WUBR_", "WUB_G","WU_RG","W_BRG",
                        "_UBRG","WUBRG"))

log.comparison[,4] <- mapvalues(log.comparison[,4],from=c("C","W","U","B","R","G", 
"WU","WB","WR","WG","UB","UR","UG","BR","BG","RG","WUB","WUR","WUG","WBR",
"WBG","WRG","UBR","UBG", "URG","BRG","WUBR", "WUBG","WURG","WBRG", "UBRG","WUBRG"),to=c("_____","W____","_U___","__B__","___R_","____G",
                        "WU___","W_B__","W__R_","W___G","_UB__","_U_R_","_U___G","__BR_",
                        "__B_G","___RG","WUB__","WU_R_","WU__G","W_BR_","W_B_G","W__RG","_UBR_",
                        "_UB_G", "_U_RG","__BRG","WUBR_", "WUB_G","WU_RG","W_BRG",
                        "_UBRG","WUBRG"))
log.comparison$Distance <- stringdist(log.comparison[,3],log.comparison[,4])
(sum(log.comparison$Distance)/nrow(log.comparison))
```
The accuracy is comparable to that of the random forest model, possibly because the majority of MTG cards are single-color or Colorless.

\section{Results}

We have found two models which predict Magic: The Gathering card Color Identities with an average error of less than one color our of five. What does this really mean? To put it into context, we evaluate the error of a model which always guesses Colorless:

```{r}
(sum(stringdist(log.comparison[,4],"_____"))/nrow(MTG.test))
```

So even guessing Colorless for every card generates an average error less than one color out of five, because the majority of cards have zero, one, or two colors. In this sense our models are unremarkable. However, using the traditional test error rather than Hamming distance, we realize that only the 1444 Colorless cards of the 10761 test cards are properly sorted: the error is .866. Given 100 cards, we would suspect only 13 to be correctly sorted, and these would clearly be coincidences. Our models are therefore impressive in actually assigning a larger portion of cards correctly than could be cheesed by always choosing any uniform Color Identity. 

If we look at a random selection of rows from rf.comparison and log.comparison, it's easy to see that even when our models are not totally accurate they provide some information about a card's Color Identity:

```{r}
set.seed(70)
example <- sample(1:nrow(rf.comparison),10)
print(rf.comparison[example,])
print(log.comparison[example,])
```
We also see the logistic regression's tendancy to guess single colors or Colorless. It supposes Karrthus, Tyrant of Jund is only Black. The random forests suppose it is five-colored (WUBRG). Both of these guesses are off by Hamming Distance 2 from the actual value, BRG. Therefore we prefer the output of the random forests: the two models have comparable test error measured traditionally and using Hamming Distance, but the random forests are more likely to guess multiple colors, and therefore its guesses communicate more information about the content of the card. 

The random forests are also valuable for their splitting variables. By observing the variables which are most important in decision-making, we understand that the subtype of a card is perhaps the most reliable indicator of its color. The forests understand that Elfs are probably Green, and cards which look White but have the subtype Vampire are probably Black or WB. If we analyzed text from the cards' names as well, the forests may have been able to tell that the word "Jund" in Karrthus, Tyrant of Jund signified its BRG Color Identity.

But even the errors in the random forest model provide insight into Magic's design. Magic: The Gathering arranges its colors in a wheel so that every color is adjacent to its two allies and opposite its two enemies: White is allied with Blue and Green, and enemies with Black and Red. When the random forests guess White for a Blue card, we understand the confusion in the overlap of the colors' philosophies. 

At the same time, multicolored cards might have access to powers which none of the component colors is associated with. For example, a card which is White/Red (WR) might be able to drain an opponent's life, an ability usually reserved for Black cards. So the forests may be prone to labeling WR cards as B, or vice versa. 

Let us check the error rate of the random forest by year:
```{r}
test.rf.err.yearly <- data.frame(matrix(ncol=1,nrow=25))

sapply(1:25, function (x) 
  {rf.pred <- predict(rf.final,TestGuesses[MTG.test[x+64]==1,])
  rf.err <- table(pred=rf.pred,truth=MTG.test$ColorIdentity[MTG.test[x+64]==1])
  test.rf.err.yearly[x,] <<- 1 - sum(diag(rf.err))/sum(rf.err)})
     # Test error by year of Magic's lifetime

yearPlot <- barplot(test.rf.err.yearly[,1],names.arg=c("93","94","95","96","97","98","99","00","01","02","03","04","05","06","07","08","09","10","11","12","13","14","15","16","17"),ylab="Error (Strict)",xlab="Year of Printing",ylim=c(.4,.7))
abline(h=0.5698355,col="Green")     # Test error for whole dataset
abline(h=0.5698355-sqrt(var(test.rf.err.yearly)),col="Red") # Plus 1 SD
abline(h=0.5698355+sqrt(var(test.rf.err.yearly)),col="Red") # Minus 1 SD
```
Test error by year has a variance of .053161. There is no obvious trend to the data, but some years have curiously high or low scores. Some interesting notes: 

In 1998 and 2004 the $Unglued$ and $Unhinged$ sets were released, joke sets where cards have humorous effects. Yet, the test errors in these years are fairly low. This may speak to the robustness of the model, as it correctly sorts these odd-ball cards, or it may suggest overfitting to these odd-ball cards at the expense of ordinary cards.

In 2000 $Prophecy$ was considered a poorly-designed set. In the same year $Invasion$ was an early block with an emphasis on multicolored cards. Both of these may explain the high error rate in 2000.

2002 saw several sets with unbalanced color proportions. $Torment$ was Black-heavy, $Judgement$ was Green-and-White-heavy. Perhaps the low test error is related to these broad trends.

2006 had $Dissension$, a multicolor-heavy set, and $Time Spiral$, a set where cards from previous sets were brought back or referenced. Perhaps these sets explain the difficulty the forests had sorting cards printed this year.

2010 saw $Rise$ $of$ $the$ $Eldrazi$ introduce large colorless creatures called the Eldrazi. These powerhouses warped the way the game was played, so cards produced at about this time may not be sortable by the methods suggested by other sets. This is my only explanation for the high test error that year.

Overall these discrepancies are small and random-looking.

Let us check the same bar plot using Hamming distance:
```{r}
test.rf.err.yearly <- data.frame(matrix(ncol=1,nrow=25))

sapply(1:25, function (x) 
  {rf.pred <- predict(rf.final,TestGuesses[MTG.test[x+64]==1,])
  rf.pred <- mapvalues(rf.pred,from=c("C","W","U","B","R","G", 
"WU","WB","WR","WG","UB","UR","UG","BR","BG","RG","WUB","WUR","WUG","WBR",
"WBG","WRG","UBR","UBG", "URG","BRG","WUBR", "WUBG","WURG","WBRG", "UBRG","WUBRG"),to=c("_____","W____","_U___","__B__","___R_","____G",
                        "WU___","W_B__","W__R_","W___G","_UB__","_U_R_","_U___G","__BR_",
                        "__B_G","___RG","WUB__","WU_R_","WU__G","W_BR_","W_B_G","W__RG","_UBR_",
                        "_UB_G", "_U_RG","__BRG","WUBR_", "WUB_G","WU_RG","W_BRG",
                        "_UBRG","WUBRG"))
  MTG.test.yearly <- mapvalues(MTG.test$ColorIdentity[MTG.test[x+64]==1],
                               from=c("C","W","U","B","R","G", 
"WU","WB","WR","WG","UB","UR","UG","BR","BG","RG","WUB","WUR","WUG","WBR",
"WBG","WRG","UBR","UBG", "URG","BRG","WUBR", "WUBG","WURG","WBRG", "UBRG","WUBRG"),to=c("_____","W____","_U___","__B__","___R_","____G",
                        "WU___","W_B__","W__R_","W___G","_UB__","_U_R_","_U___G","__BR_",
                        "__B_G","___RG","WUB__","WU_R_","WU__G","W_BR_","W_B_G","W__RG","_UBR_",
                        "_UB_G", "_U_RG","__BRG","WUBR_", "WUB_G","WU_RG","W_BRG",
                        "_UBRG","WUBRG"))
  test.rf.err.yearly[x,] <<- sum(stringdist(rf.pred,MTG.test.yearly))/length(rf.pred)})

yearPlot <- barplot(test.rf.err.yearly[,1],names.arg=c("93","94","95","96","97","98","99","00","01","02","03","04","05","06","07","08","09","10","11","12","13","14","15","16","17"),ylab="Error (Hamming)",xlab="Year of Printing",ylim=c(.7,1.2))
abline(h=0.9491683,col="Green")
abline(h=0.9491683-sqrt(var(test.rf.err.yearly)),col="Red")
abline(h=0.9491683+sqrt(var(test.rf.err.yearly)),col="Red")
```
This is too similar to the previous plot to say much, except justify Hamming Distance as a measurement of correctness.  




\section{Conclusions}

Although we were able to algorithmically sort Magic: The Gathering cards by Color-Identity with relative reliability, there is much room for improvement. The whole set of Magic cards presents uniquely complicated problems in data-mining. There are cards which are double-sided, and even cards which have two miniature cards printed on the same side. When a card with Power or Toughness "*/*" or "X/X" is to be sorted, the method for choosing * or X should be considered. Some keywords, such as "counter," can mean different things depending on context (it may mean to counter a spell, or it may mean to place a counter on a spell) and the different meanings are related to different colors. Artifacts are usually Colorless, but exceptions exist. Perhaps no perfect algorithm exists for guessing Color Identity.

Even the Magic: The Gathering designers can get it wrong. Magic's lead designer Mark Rosewater laments the decisions made in a set called "Planar Shift" where they mixed color-philosophies in non-traditional ways. Even considering this, Magic's design has changed over its lifetime. Abilities once considered taboo in Red like card-drawing have been reconsidered. The designers find interesting ways to allow cards of different colors to perform effects in a way consistant with their philosophies. 

Knowing this, maybe our analytic approach could be helpful in assigning Color Identities in future sets. This could be used to enforce a consistent feeling for each Color Identity.

\clearpage
\section{References}

Schults, Robert. "Provides Magic: the Gathering Card Data in JSON Format." $MTG JSON$, 13 Nov. 2017, mtgjson.com/.

\null 

Rosewater, Mark. "Mechanical Color Pie 2017." $MAGIC:$ $THE$ $GATHERING$, Wizards of the Coast, 5 June 2017, magic.wizards.com/en/articles/archive/making-magic/mechanical-color-pie-2017-2017-06-05.

\null 

"RoboRosewater (\@RoboRosewater)." $Twitter$, 3 July 2015, twitter.com/RoboRosewater?ref_src=twsrc%5Egoogle
%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor.

\null 

"Gatherer." $Magic:$ $The$ $Gathering$, Wizards of the Coast, gatherer.wizards.com/Pages/Default.aspx.
